<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async - Разработка и применение программного обеспечения в физических исследованиях</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro/intro.html">О книге</a></li><li class="chapter-item expanded affix "><li class="part-title">Загружаем linux</li><li class="chapter-item expanded "><a href="../linux/intro.html"><strong aria-hidden="true">1.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../linux/structure.html"><strong aria-hidden="true">1.1.</strong> Устройство</a></li><li class="chapter-item expanded "><a href="../linux/tools.html"><strong aria-hidden="true">1.2.</strong> Инструменты</a></li><li class="chapter-item expanded "><a href="../linux/internals.html"><strong aria-hidden="true">1.3.</strong> Внутренности</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Учим теорию</li><li class="chapter-item expanded "><a href="../cs/intro.html"><strong aria-hidden="true">2.</strong> Общие знания CS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cs/basic-algos.html"><strong aria-hidden="true">2.1.</strong> Введение в алгоритмы</a></li><li class="chapter-item expanded "><a href="../cs/basic-structures.html"><strong aria-hidden="true">2.2.</strong> Основные структуры данных</a></li><li class="chapter-item expanded "><a href="../cs/recurs-and-sorts.html"><strong aria-hidden="true">2.3.</strong> Рекурсия и сортировки</a></li><li class="chapter-item expanded "><a href="../cs/hash-funcs.html"><strong aria-hidden="true">2.4.</strong> Хеш-функции</a></li></ol></li><li class="chapter-item expanded "><a href="../compute/intro.html"><strong aria-hidden="true">3.</strong> Введение в вычислительную физику</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../compute/basic-concepts.html"><strong aria-hidden="true">3.1.</strong> Понятия сходимости, аппроксимации и устойчивости</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Устанавливаем python</li><li class="chapter-item expanded "><a href="../dev/intro.html"><strong aria-hidden="true">4.</strong> Разработка ПО</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/py.html"><strong aria-hidden="true">4.1.</strong> Python</a></li><li class="chapter-item expanded "><a href="../dev/app.html"><strong aria-hidden="true">4.2.</strong> Прикладное программирование</a></li><li class="chapter-item expanded "><a href="../dev/life.html"><strong aria-hidden="true">4.3.</strong> Жизненный цикл</a></li><li class="chapter-item expanded "><a href="../dev/bd.html"><strong aria-hidden="true">4.4.</strong> Базы данных</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Обрабатываем данные</li><li class="chapter-item expanded "><a href="../ds/intro.html"><strong aria-hidden="true">5.</strong> Обработка и анализ данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ds/tools.html"><strong aria-hidden="true">5.1.</strong> Инструменты</a></li><li class="chapter-item expanded "><a href="../ds/basic.html"><strong aria-hidden="true">5.2.</strong> Базовые алгоритмы</a></li><li class="chapter-item expanded "><a href="../ds/nn.html"><strong aria-hidden="true">5.3.</strong> Нейронные сети</a></li><li class="chapter-item expanded "><a href="../ds/ml.html"><strong aria-hidden="true">5.4.</strong> Машинное обучение</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Профилируем, оптимизируем, ускоряем</li><li class="chapter-item expanded "><a href="../perf/intro.html"><strong aria-hidden="true">6.</strong> Быстрее Python! Еще быстрее!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../perf/perf.html"><strong aria-hidden="true">6.1.</strong> Performance</a></li><li class="chapter-item expanded "><a href="../perf/gil.html"><strong aria-hidden="true">6.2.</strong> Multithreading and GIL</a></li><li class="chapter-item expanded "><a href="../perf/async.html" class="active"><strong aria-hidden="true">6.3.</strong> Async</a></li><li class="chapter-item expanded "><a href="../perf/cuda.html"><strong aria-hidden="true">6.4.</strong> CUDA</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Учимся у других</li><li class="chapter-item expanded "><a href="../examples/intro.html"><strong aria-hidden="true">7.</strong> Коды и скрипты</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/kenv.html"><strong aria-hidden="true">7.1.</strong> Уравнение огибающей Капчинского-Владимирского для пучка заряженных частиц</a></li><li class="chapter-item expanded "><a href="../examples/redpic.html"><strong aria-hidden="true">7.2.</strong> Релятивисткая разностная схема для расчета динамики частиц в сложных электрических и магнитных полях</a></li><li class="chapter-item expanded "><a href="../examples/envelope-optimize.html"><strong aria-hidden="true">7.3.</strong> Оптимизация огибающей пучка заряженных частиц с помощью генетического алгоритма</a></li><li class="chapter-item expanded "><a href="../examples/orbit-correction.html"><strong aria-hidden="true">7.4.</strong> Коррекция равновесной орбиты в ускорителе заряженных частиц с применением матрицы отклика и нейронных сетей</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Резюме</li><li class="chapter-item expanded "><a href="../resume/intro.html"><strong aria-hidden="true">8.</strong> Резюме</a></li><li class="chapter-item expanded "><a href="../resume/literature.html"><strong aria-hidden="true">9.</strong> Литература</a></li><li class="chapter-item expanded "><a href="../resume/about-me.html"><strong aria-hidden="true">10.</strong> О себе</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Разработка и применение программного обеспечения в физических исследованиях</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fuodorov/physicist-developer-book/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="async-python"><a class="header" href="#async-python">Async python</a></h1>
<p>Нам предстоит погрузиться в мир асинхронного программирования. Сейчас уже сложно представить Python без асинхронного подхода — он только набирает популярность среди веб-разработчиков.</p>
<h2 id="Асинхронный-подход"><a class="header" href="#Асинхронный-подход">Асинхронный подход</a></h2>
<p>Сегодня мы изучим следующие темы:</p>
<ul>
<li>итераторы, генераторы и корутины
<ul>
<li>итераторы;</li>
<li>генераторы и корутины;</li>
</ul>
</li>
<li>асинхронность в Python и asyncio
<ul>
<li>асинхронное программирование;</li>
<li>event-loop;</li>
<li>asyncio;</li>
</ul>
</li>
<li>асинхронные фреймворки
<ul>
<li>twisted;</li>
<li>aiohttp;</li>
<li>fastapi;</li>
</ul>
</li>
<li>async API</li>
</ul>
<h2 id="Итераторы"><a class="header" href="#Итераторы">Итераторы</a></h2>
<p>Разработчики используют итераторы в коде настолько часто, что даже не задумываются, в чём они помогают. Итераторы в Python — это списки, словари, множества, строки, файлы и другие коллекции. Везде, где вы пишете цикл <code>for</code>, используется итератор. Итераторы помогают перемещаться по объектам любого контейнера в коде. При этом вам не нужно задумываться о том, как хранятся и обрабатываются эти элементы: итератор инкапсулирует их. Проще говоря, это способ вычитывать элементы из объекта по одному.</p>
<p>Перейдём сразу к практике. Представим, что на собеседовании вас попросили реализовать аналог функции <code>range</code>.</p>
<pre><code class="language-python">class Range:
    def __init__(self, stop_value: int):
        self.current = -1
        self.stop_value = stop_value - 1
        
    def __iter__(self):
        return RangeIterator(self)
    
</code></pre>
<pre><code class="language-python">class RangeIterator:
    def __init__(self, container):
        self.container = container
  
    def __next__(self):
        if self.container.current &lt; self.container.stop_value:
            self.container.current += 1
            return self.container.current
        raise StopIteration
</code></pre>
<p>Получили первую версию работающего кода. Запустим код и убедимся в этом.</p>
<pre><code class="language-python">_range = Range(5)

for i in _range:
    print(i) 
</code></pre>
<pre><code>0
1
2
3
4
</code></pre>
<h3 id="А-как-это-работает-Расскажите-подробнее"><a class="header" href="#А-как-это-работает-Расскажите-подробнее">«А как это работает? Расскажите подробнее»</a></h3>
<p>Начнём с класса <code>Range</code>. У него внутри реализован магический метод <code>__iter__</code>. Он обозначает, что объект этого класса итерабельный, то есть с ним можно работать в цикле <code>for</code>. Ещё говорят, что <code>__iter__</code> отдаёт <a href="https://docs.python.org/3.7/library/stdtypes.html#iterator.__iter__">итерируемый объект</a>.</p>
<p>Ограничимся понятиями итератора и итерабельного объекта. Чтобы код действительно отдавал новые данные из <code>range</code>, нужно реализовать соответствующую функцию. Она как раз и называется итератор. <code>RangeIterator</code> — итератор для класса <code>range</code>. Любой итератор должен реализовывать магическую функцию <code>__next__</code>, в которой он должен отдавать новые значения для объектов класса <code>Range</code>. Если вы дошли до конца множества значений, то появляется исключение <code>StopIteration</code>.</p>
<p>Для тех, кто привык читать первоисточники, существует <a href="https://www.python.org/dev/peps/pep-0234/">PEP-234</a> (на английском). Там подробно изложена работа итераторов и итерабельных объектов.</p>
<p>Но можно ли как-то упростить написанный выше код? Да, можно.</p>
<pre><code class="language-python">class Range2:
    def __init__(self, stop_value: int):
        self.current = -1
        self.stop_value = stop_value - 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current &lt; self.stop_value:
            self.current += 1
            return self.current
        raise StopIteration 
</code></pre>
<p>В Python есть возможность объявить объекты класса и итерабельными, и итераторами. Это удобно, но с точки зрения принципов проектирования приложения, у такого объекта есть две ответственности: он является итератором и при этом выполняет какую-то свою логику. В мире Python это допустимо, но в некоторых других языках вас могут понять неправильно. Будьте бдительны!</p>
<p>Ещё стоит рассмотреть, как работает цикл <code>for</code> под капотом.</p>
<pre><code class="language-python">iterable = Range2(5)
iterator = iter(iterable)

while True:
    try:
        value = next(iterator)
        print(value)
    except StopIteration:
        break 
</code></pre>
<pre><code>0
1
2
3
4
</code></pre>
<h2 id="Генераторы"><a class="header" href="#Генераторы">Генераторы</a></h2>
<p>Работа генераторов построена на принципе запоминания контекста выполнения функции. Если не вдаваться в подробности работы Python-интерпретатора, то функция-генератор «запоминает», на каком месте она остановилась, и может продолжить своё выполнение после ключевого слова <code>yield</code>.</p>
<p>Рассмотрим простой пример.</p>
<pre><code class="language-python">def simple_generator():
    yield 1
    yield 2
    return 3
</code></pre>
<p>Посмотрим, что будет, если вызвать такой код:</p>
<pre><code class="language-python">gen = simple_generator()
print(next(gen))
print(next(gen))
print(next(gen))
</code></pre>
<pre><code>1
2



---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

Cell In[7], line 4
      2 print(next(gen))
      3 print(next(gen))
----&gt; 4 print(next(gen))


StopIteration: 3
</code></pre>
<p>То есть функция действительно запоминает, где она остановилась после каждого вызова функции <code>next</code>.</p>
<p>Генераторы удобны и для создания генераторных выражений — <code>generator expressions</code>. Особенно это полезно, если нужно сгенерировать много объектов, а память расходовать жалко. Код выглядит так:</p>
<pre><code class="language-python">gen_exp = (x for x in range(100000))
print(gen_exp)
</code></pre>
<pre><code>&lt;generator object &lt;genexpr&gt; at 0x7dbe33f1dfc0&gt;
</code></pre>
<p>Есть ещё небольшой синтаксический сахар, связанный с генераторами. Представим функцию, внутри которой есть цикл по элементам списка, и они выводятся один за другим.</p>
<pre><code class="language-python">numbers = [1, 2, 3]
def func():
    for item in numbers:
        yield item

for item in func():
  print(item)
</code></pre>
<pre><code>1
2
3
</code></pre>
<p>За счёт генератора конструкция сокращается до такой:</p>
<pre><code class="language-python">def func():
    yield from numbers
</code></pre>
<p>Бывает очень полезно, но на практике используется довольно редко.</p>
<h2 id="Корутины"><a class="header" href="#Корутины">Корутины</a></h2>
<p>Затронем тему корутин — основных строительных блоков асинхронного программирования на Python. Они появились в ответ на невозможность использования полноценного распараллеливания программы с помощью тредов (потоков) из-за работы <code>GIL</code>. Для тех, кому интересно узнать подробнее про <code>Global Interpreter Lock</code>, есть хорошая обзорная <a href="https://tproger.ru/translations/global-interpreter-lock-guide/">статья</a>.</p>
<p>Корутина — это генератор. Однако в <a href="https://www.python.org/dev/peps/pep-0342/">PEP-342</a> предложили расширить возможности генераторов, добавив туда несколько конструкций, о которых сейчас пойдёт речь.</p>
<p>Представьте себе метод, который на вход получает какое-то значение, как-то его обрабатывает и отдаёт результат. Пусть это будет функция, рассчитывающая количество денег на вашем счете через $N$ лет при определённом проценте. На вход функция принимает процент по депозиту в годовых и сумму на счёте.</p>
<pre><code class="language-python">import math

def cash_return(deposit: int, percent: float, years: int) -&gt; float:
    value = math.pow(1 + percent / 100, years)
    return round(deposit * value, 2)
</code></pre>
<p>Теперь узнаем, сколько вы получите денег через $5$ лет, если сумма на депозите — $1 000 000$ рублей, а ставка по депозиту — $5%%$ годовых.</p>
<pre><code class="language-python">cash_return(1_000_000, 5, 5)
</code></pre>
<pre><code>1276281.56
</code></pre>
<p>Теперь вы хотите посмотреть на то, как будет меняться итоговая сумма в зависимости от депозита. Тут приходит на помощь корутина.</p>
<pre><code class="language-python">import math

def cash_return_coro(percent: float, years: int) -&gt; float:
    value = math.pow(1 + percent / 100, years)
    while True:
        try:
            deposit = (yield)
            yield round(deposit * value, 2)
        except GeneratorExit:
            print('Выход из корутины')
            raise
</code></pre>
<p>Запустим корутину с теми же условиями — $5$ лет и $5%%$ годовых.</p>
<pre><code class="language-python">coro = cash_return_coro(5, 5)
next(coro)
values = [1000, 2000, 5000, 10000, 100000]
for item in values:
    print(coro.send(item))
    next(coro)
coro.close() 
</code></pre>
<pre><code>1276.28
2552.56
6381.41
12762.82
127628.16
Выход из корутины
</code></pre>
<p>Разберёмся, что произошло. В коде видно четыре новых конструкции: <code>(yield)</code>, <code>send(...)</code>, <code>close()</code> и <code>GeneratorExit</code>. Корутины могут не только отдавать значения и запоминать место, где остановился код, но и ждать новых значений. Для этого ввели конструкцию <code>(yield)</code>, которая позволяет принимать набор параметров. Так как приём параметров в корутине происходит необычным способом, то и отправка параметров сделана с помощью специальной функции <code>send(...)</code>, через которую можно передать в функцию необходимые параметры. В конце ещё можно вызвать метод <code>close()</code>, который прекратит выполнение корутины. Когда вы вызываете метод <code>close()</code>, выбрасывается исключение <code>GeneratorExit</code>, которое можно перехватить и грамотно обработать.</p>
<p>Ещё одно преимущество — возможность запомнить контекст выполнения. В функции <code>cash_return_coro</code> нет необходимости вычислять переменную <code>value</code> каждый раз, когда вы хотите посчитать сумму. Недостатком такого подхода можно назвать большее количество кода, который надо написать, чтобы всё могло грамотно работать.</p>
<h2 id="Асинхронное-программирование"><a class="header" href="#Асинхронное-программирование">Асинхронное программирование</a></h2>
<p>Асинхронное программирование в мире Python-разработки на пике популярности. Про него пишут статьи и делают доклады на конференциях. Концепция уже прижилась и во многих других популярных языках. Давайте восполним пробелы и погрузимся в работу с асинхронным кодом на Python.</p>
<h3 id="Работа-с-разными-типами-задач"><a class="header" href="#Работа-с-разными-типами-задач">Работа с разными типами задач</a></h3>
<p>Раньше разработчики не сильно заостряли своё внимание на типе выполняемых задач внутри приложения — это было не нужно для индустрии в целом. Все писали достаточно большие монолитные приложения, а проблемы с производительностью обычно решались на уровне горизонтального масштабирования: через потоки, процессы или даже через несколько приложений на разных виртуальных машинах.</p>
<p>Сейчас использование только процессов и потоков не даёт нужной производительности. Рассмотрим три основных типа задач, с которыми сталкивается большинство разработчиков:</p>
<ul>
<li>
<p><strong>CPU bound-задачи.</strong> Задачи, для которых необходимо интенсивное использование процессора. К ним относят использование сложных математических моделей, обучение нейронных сетей, рендеринг графики и вычисление хэшей.</p>
</li>
<li>
<p><strong>I/O bound-задачи (non-RAM I/O bound).</strong> Задачи, в которых основная часть работы приходится на ввод/вывод информации <em>I/O</em> или <em>input/output</em>. В основном такие задачи относятся к работе с файловой системой и с сетью.</p>
</li>
<li>
<p><strong>Memory bound-задачи (RAM I/O bound).</strong> Задачи, в которых происходит интенсивная работа с оперативной памятью. Как правило, такие задачи появляются в сложных математических моделях. Из-за медленной работы с оперативной памятью всё больше моделей обрабатывают с помощью видеокарт, в которых работа с памятью устроена по-другому. Другой пример — обработка огромного объёма данных в <em>Map-Reduce</em>-системах, например, таких как <em>Spark</em>. Обработка будет идти быстрее, если оперативной памяти будет больше.</p>
</li>
</ul>
<p>Подробнее об этом можно прочитать в англоязычных статьях: - <a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean">о значении терминов CPU bound и I/O bound</a>, - <a href="https://link.springer.com/chapter/10.1007/978-1-4842-4932-1_15">о производительности</a>.</p>
<p>Из-за массового перехода на микросервисы количество сетевого взаимодействия между системами многократно возросло, как и нагрузка на базы данных. Проблемы работы с сетью или с доступом к БД относятся к I/O bound-задачам. То есть их основная работа — ожидание обработки запроса к внешней системе. Такой класс задач в монолитных системах решался пулом потоков — <a href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a>. Однако, его стало не хватать из-за достаточно интенсивной нагрузки на сеть между множеством сервисов.</p>
<p>Классический метод решения I/O bound задач — добавление ресурсов к существующим системам. Однако, многие компании не могут позволить себе «заливать всё железом» — докупать новые железные серверы, вместо оптимизации кода. Например, Instagram может себе такое позволить, поэтому они до сих пор используют Django даже с учётом всей нагрузки.</p>
<p>Перейдём к практике. Представьте приложение, которое ходит на некий сайт-агрегатор, достаёт данные по фильмам и сохраняет в БД. Код будет выглядеть так (ссылка на сайт выдуманная):</p>
<pre><code class="language-python">import requests

def do_some_logic(data):
    pass
  
def save_to_database(data):
    pass

data = requests.get('https://data.aggregator.com/films')
processed_data = do_some_logic(data)
save_to_database(data)
</code></pre>
<p>Этот код достаточно линейный. Если вместо загрузки фильмов в БД такой код будет выполнять отдачу данных о фильмах с этого же сайта, то при достаточной нагрузке приложение начнёт сильно проседать по скорости ответа клиентам. При этом бо́льшую часть времени код будет просто ждать запроса от клиента, делать запрос к сайту https://data.aggregator.com/films и отдавать данные. То есть в эти моменты интерпретатор не будет делать никаких полезных действий, а клиенты будут ждать.</p>
<p>Схематично изобразить выполнение программы можно вот так:</p>
<p><img src="1_1_AsyncAPI_1_1629286149.png" alt="1_1_AsyncAPI_1_1629286149.png" /></p>
<p>Теперь определим тип задачи в каждой ячейке:</p>
<p><img src="1.1_3_AsyncAPI_1_1629286157.png" alt="1.1_3_AsyncAPI_1_1629286157.png" /></p>
<p>Интуитивно выполнение программы кажется примерно таким, как указано на картинке выше.</p>
<p><img src="1.1_3_AsyncAPI_1_1629286157.png" alt="1.1_3_AsyncAPI_1_1629286157.png" /></p>
<p>Однако, если привести картинку в соответствие с реальностью, получим следующий результат:</p>
<p><img src="1_2_AsyncAPI_2_1629286153.png" alt="1_2_AsyncAPI_2_1629286153.png" /></p>
<p>То есть бо́льшую часть времени программа ждёт ввода/вывода, а меньшая часть времени отводится на выполнение полезной работы.
Эту проблему можно решить, распараллелив код на процессы и потоки. Такой вариант поможет, но на короткое время — при таком подходе сильно увеличатся расходы ресурсов сервера. Плюс количество допустимых процессов и потоков ограничено. То есть либо закончится оперативная память под потоки, либо закончатся ядра под процессы. Вишенкой на торте становится <code>GIL</code>, который даёт работать только одному потоку в единицу времени. Это не позволяет эффективно использовать массовый параллелизм на потоках и добавляет свои накладные расходы, хоть и не очень заметные.</p>
<p>Посмотрим, как применение потоков сказывается на выполнении программы:</p>
<p><img src="S1.1_4_AsyncAPI_1_1629286161.png" alt="S1.1_4_AsyncAPI_1_1629286161.png" /></p>
<p>Действительно, два потока почти в два раза лучше отрабатывают I/O bound задачи. Но к сожалению, при таком подходе очень просто ошибиться и столкнуться с проблемой <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D0%BD%D0%BA%D0%B8">«состояния гонок»</a>. Можно попробовать вариант с корутинами, но его сложнее реализовать. И при таком способе не получится создать много потоков, так как они потребляют гораздо больше ОЗУ, чем корутины. Также написание многопоточного кода требует от разработчика большей внимательности, чем при написании линейного.</p>
<p>Стоит внимательнее присмотреться к проблеме. Всё ещё бо́льшую часть времени интерпретатор не совершает активных действий, а только ждёт ответа от ОС, завершилась ли та или иная операция ввода/вывода. В целом процессы и потоки не сильно помогут, ведь интерпретатор будет по-прежнему простаивать на каждом из них. При этом появится много накладных расходов на переключение контекста между процессами или на потребление оперативной памяти потоками, что может только ухудшить положение.</p>
<p>Все эти проблемы необходимо решать эффективно. С этим может помочь использование асинхронного кода.</p>
<h2 id="event-loop"><a class="header" href="#event-loop">Event-loop</a></h2>
<p>Итак, вы добрались до сердца асинхронных программ в Python — цикла событий. Чтобы понять, как он работает, обратимся к простой реализации, которую предложил Девид Бизли (David Beazley) <a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">в 2009 году</a>. Она хороша тем, что не содержит сложных конструкций, которыми сейчас обросли популярные реализации цикла событий на Python. Эта часть будет построена на разборе кода и практик, которые применяются для разработки цикла событий на основе <a href="http://www.dabeaz.com/coroutines/pyos8.py">кода Бизли</a>, и как учитывать эти знания при разработке асинхронных приложений на Python. Код уже приведён к современной версии Python.</p>
<p>Начнём с архитектуры цикла событий.</p>
<p><img src="1_Event_Loop_1629282397.png" alt="1_Event_Loop_1629282397.png" /></p>
<p>Расмотрим блоки:</p>
<ul>
<li><strong>Планировщик (Scheduler)</strong>. Корень всей программы. Обрабатывает задачи в очереди задач и следит за их правильным переключением между собой.</li>
<li><strong>Очередь задач (Task queue)</strong>. Здесь собираются новые задачи на исполнение.</li>
<li><strong>Задача (Task)</strong>. Основной блок работы цикла событий. В задачах хранится информация о выполняемой корутине. Умеет обрабатывать цепочку вложенных корутин.</li>
<li><strong>Корутина (Coroutine)</strong>. Исполняемый код, которым оперирует планировщик задач.</li>
<li><strong>Системный вызов (SystemCall)</strong>. Блоки кода, которые расширяют функциональность планировщика.</li>
<li><strong>Корутина для выполнения работы с I/O (I/O-tasks)</strong>. В планировщик добавляется специальная задача (Task) для обработки I/O-событий от ОС.</li>
<li><strong>Селектор (Selector)</strong>. Он слушает события от ОС и передаёт работу корутинам, которые ждут обработки I/O-сообщений.</li>
</ul>
<p>Первым стоит рассмотреть работу планировщика. Его основные функции — приём и справедливая обработка списка задач.</p>
<pre><code class="language-python">import logging
from typing import Generator
from queue import Queue


class Scheduler:
    def __init__(self):
        self.ready = Queue()
        self.task_map = {}

    def add_task(self, coroutine: Generator) -&gt; int:
        new_task = Task(coroutine)
        self.task_map[new_task.tid] = new_task
        self.schedule(new_task)
        return new_task.tid

    def exit(self, task: Task):
        del self.task_map[task.tid]

    def schedule(self, task: Task):
        self.ready.put(task)

    def _run_once(self):
        task = self.ready.get()
        try:
            result = task.run()
        except StopIteration:
            self.exit(task)
            return
        self.schedule(task)

    def event_loop(self):
        while self.task_map:
            self._run_once()
</code></pre>
<p>Вся работа происходит в функции <code>event_loop()</code>, которая просто достаёт задачи одну за другой. В функции <code>_run_once()</code> идёт обработка итерации цикла событий, в которой поочерёдно берутся и запускаются задачи для обработки. Если задача не завершилась, то она ставится заново в очередь задач <code>self.ready</code>. Выполненные задачи нужно убрать из планировщика функцией <code>exit()</code>.</p>
<p>Для добавления задачи используйте функцию <code>add_task()</code>. Она принимает корутину для выполнения и создаёт с ней задачу в планировщике. Чтобы поставить задачу напрямую в планировщик, необходимо вызвать функцию <code>schedule()</code>.</p>
<p>Далее разберёмся с устройством задачи.</p>
<pre><code class="language-python">import types
from typing import Generator, Union

class Task:
    task_id = 0

    def __init__(self, target: Generator):
        Task.task_id += 1
        self.tid = Task.task_id  # Task ID
        self.target = target  # Target coroutine
        self.sendval = None  # Value to send
        self.stack = []  # Call stack

    # Run a task until it hits the next yield statement
    def run(self):
        while True:
            try:
                result = self.target.send(self.sendval)

                if isinstance(result, types.GeneratorType):
                    self.stack.append(self.target)
                    self.sendval = None
                    self.target = result
                else:
                    if not self.stack:
                        return
                    self.sendval = result
                    self.target = self.stack.pop()

            except StopIteration:
                if not self.stack:
                    raise
                self.sendval = None
                self.target = self.stack.pop()
</code></pre>
<p>Сама по себе задача — обёртка над корутиной. У каждой задачи есть свой <code>id</code>, который учитывается в планировщике в словаре <code>task_map</code>. На его заполненность смотрит планировщик при выполнении задач.</p>
<p>Другая особенность задач — возможность выполнения корутин методом <code>run()</code>. Давайте посмотрим, как они выполняются в рамках задачи. Предположим, что есть корутина, которая вызывает другую корутину, а та — третью. Например, вот такой код:</p>
<pre><code class="language-python">def double(x):
    yield x * x

def add(x, y):
    yield from double(x + y)

def main():
    result = yield add(1, 2)
    print(result)
    yield
</code></pre>
<p>Код является небольшой модификацией <a href="http://www.dabeaz.com/coroutines/trampoline.py">кода Бизли</a> из его выступления. Теперь попробуем выполнить эту цепочку корутин в рамках <code>Task</code>.</p>
<pre><code class="language-python">task = Task(main())
task.run()
</code></pre>
<pre><code>9
</code></pre>
<p>Таким же образом будут выполняться и остальные корутины в рамках планировщика. Осталось только расширить планировщик для работы с I/O-операциями.</p>
<p>В рамках планировщика добавляем специальную бесконечную задачу <code>io_task</code> перед стартом цикла событий. Эта функция имеет бесконечный цикл внутри и передаёт управление планировщику после вызова выполненных событий из селектора.</p>
<pre><code class="language-python">import logging
from typing import Generator, Union
from queue import Queue
from selectors import DefaultSelector, EVENT_READ, EVENT_WRITE


logger = logging.getLogger(__name__)


class Scheduler:
    def __init__(self):
        self.ready = Queue()
        self.selector = DefaultSelector()
        self.task_map = {}

    def add_task(self, coroutine: Generator) -&gt; int:
        new_task = Task(coroutine)
        self.task_map[new_task.tid] = new_task
        self.schedule(new_task)
        return new_task.tid

    def exit(self, task: Task):
        logger.info('Task %d terminated', task.tid)
        del self.task_map[task.tid]

    # I/O waiting
    def wait_for_read(self, task: Task, fd: int):
        try:
            key = self.selector.get_key(fd)
        except KeyError:
            self.selector.register(fd, EVENT_READ, (task, None))

        else:
            mask, (reader, writer) = key.events, key.data
            self.selector.modify(fd, mask | EVENT_READ, (task, writer))

    def wait_for_write(self, task: Task, fd: int):
        try:
            key = self.selector.get_key(fd)
        except KeyError:
            self.selector.register(fd, EVENT_WRITE, (None, task))

        else:
            mask, (reader, writer) = key.events, key.data
            self.selector.modify(fd, mask | EVENT_WRITE, (reader, task))

    def _remove_reader(self, fd: int):
        try:
            key = self.selector.get_key(fd)
        except KeyError:
            pass
        else:
            mask, (reader, writer) = key.events, key.data
            mask &amp;= ~EVENT_READ
            if not mask:
                self.selector.unregister(fd)
            else:
                self.selector.modify(fd, mask, (None, writer))

    def _remove_writer(self, fd: int):
        try:
            key = self.selector.get_key(fd)
        except KeyError:
            pass
        else:
            mask, (reader, writer) = key.events, key.data
            mask &amp;= ~EVENT_WRITE
            if not mask:
                self.selector.unregister(fd)
            else:
                self.selector.modify(fd, mask, (reader, None))

    def io_poll(self, timeout: Union[None, float]):
        events = self.selector.select(timeout)
        for key, mask in events:
            fileobj, (reader, writer) = key.fileobj, key.data
            if mask &amp; EVENT_READ and reader is not None:
                self.schedule(reader)
                self._remove_reader(fileobj)
            if mask &amp; EVENT_WRITE and writer is not None:
                self.schedule(writer)
                self._remove_writer(fileobj)

    def io_task(self) -&gt; Generator:
        while True:
            if self.ready.empty():
                self.io_poll(None)
            else:
                self.io_poll(0)
            yield

    def schedule(self, task: Task):
        self.ready.put(task)

    def _run_once(self):
        task = self.ready.get()
        try:
            result = task.run()
        except StopIteration:
            self.exit(task)
            return
        self.schedule(task)

    def event_loop(self):
        self.add_task(self.io_task())
        while self.task_map:
            self._run_once()
</code></pre>
<p>Код значительно разросся, но на самом деле ничего страшного не произошло. Рассмотрим изменения в порядке вызовов. В рамках планировщика добавляем специальную бесконечную задачу <code>io_task</code> перед стартом цикла событий. Эта функция имеет бесконечный цикл внутри и передаёт управление планировщику после вызова выполненных событий из селектора.</p>
<p>Рассмотрим подробнее устройство <code>io_task</code>. Если очередь задач пустая, то timeout для ожидания событий из селектора ставится в режим «до тех пор, пока не будет новых событий». В остальных случаях ставим таймаут 0, чтобы получить все события от ОС сразу же. Такую особенность работы этого метода рассмотрим чуть позже.</p>
<p>Если из селектора пришли новые события, то обрабатываем их и убираем из обработки файловые дескрипторы. Важный момент — хранение данных о задачах в селекторе. Одна и та же задача может ожидать чтения данных и пытаться записать новые данные. Именно поэтому в поле <code>data</code> хранится кортеж <code>(reader, writer)</code>.</p>
<p>По сути, <code>event_loop</code> должен предоставлять интерфейс для работы с сокетами. Таких метода всего четыре:</p>
<ul>
<li><code>wait_for_read</code>,</li>
<li><code>wait_for_write</code>,</li>
<li><code>_remove_reader</code>,</li>
<li><code>_remove_writer</code>.</li>
</ul>
<p>Эти методы позволяют работать с циклом событий, встроенным в ОС.</p>
<p>Работа с I/O для цикла событий — «пристройка сбоку» для обработки сетевых запросов. То есть основное назначение цикла событий в Python — обработка функций корутин, которые могут никуда не ходить по сети, а работать только с файловой системой.</p>
<p>Осталось разобраться с конструкцией <code>SystemCall</code>. Так как изначально цикл событий больше напоминает работу ОС, должен быть механизм прерываний, чтобы передать управление ОС. В асинхронном коде прерывание обеспечивается с помощью <code>yield</code>. После переключения контекста может вызываться системная функция для исполнения. Например, для создания новых задач можно использовать вот такой код:</p>
<pre><code class="language-python">class SystemCall:
    def handle(self, sched: Scheduler, task: Task):
        pass


class NewTask(SystemCall):
    def __init__(self, target: Generator):
        self.target = target

    def handle(self, sched: Scheduler, task: Task):
        tid = sched.add_task(self.target)
        task.sendval = tid
        sched.schedule(task)
</code></pre>
<p>В <code>Scheduler</code> достаточно добавить небольшой фрагмент кода:</p>
<pre><code class="language-python">class Scheduler:
    ...
    def _run_once(self):
        task = self.ready.get()
        try:
            result = task.run()
            if isinstance(result, SystemCall):
                result.handle(self, task)
                return
        except StopIteration:
            self.exit(task)
            return
        self.schedule(task)
</code></pre>
<p>А в <code>Task</code> добавляем небольшое условие при выполнении корутин:</p>
<pre><code class="language-python">import types
from typing import Generator, Union

class Task:
    ...
    def run(self):
        while True:
            try:
                result = self.target.send(self.sendval)
                if isinstance(result, SystemCall):
                    return result
                ...
</code></pre>
<p>Что всё это значит? Разберёмся на примере <code>NewTask</code>. Этот класс предоставляет интерфейс для создания новых задач в цикле событий. Такой интерфейс позволяет абстрагировать клиентский код. Это эмуляция защищённой среды ОС, когда последняя предоставляет безопасные методы для работы с ядром. Такие методы не дают клиентскому коду мешать другим программам в ОС. Таким же образом можно сделать <code>KillTask</code> или <code>WaitTask</code>.</p>
<p>Осталась последняя проблема — блокирующие операции. Из-за них код не может асинхронно обрабатывать события и цикл событий ждёт выполнения на каждой функции. Есть вариант решения проблемы:</p>
<ul>
<li>Сделать неблокирующими сокеты через <code>socket.setblocking(False)</code>.</li>
</ul>
<h2 id="asyncio"><a class="header" href="#asyncio">Asyncio</a></h2>
<p>Теперь у нас достаточно знаний, чтобы без труда освоить основную встроенную библиотеку для асинхронного программирования — <code>asyncio</code>.</p>
<p>С версии Python 3.5 в язык добавили специальный синтаксис — async/await. Он позволяет использовать «нативные» корутины, которые теперь являются частью языка. Они разделяют генераторы от асинхронного кода, что позволяет создавать асинхронные генераторы и ускорять работу асинхронного кода.</p>
<p>Посмотрим, как выглядит простая программа с использованием async/await.</p>
<pre><code class="language-python">import random
import asyncio


async def func():
    r = random.random()
    await asyncio.sleep(r)
    return r


async def value():
    result = await func()
    print(result)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(value())
    loop.close()
</code></pre>
<p>В целом изменений немного. Переменная <code>loop</code> — это не что иное, как планировщик задач. Он работает по схожим принципам с тем, что рассматривался ранее. Теперь все функции переключаются с помощью <code>await</code>.</p>
<p>Познакомимся с основными функциями <code>asyncio</code>, которые часто встречаются на практике:</p>
<ul>
<li><code>gather</code> — выполняет список корутин одновременно и дожидается результата выполнения всех корутин.</li>
<li><code>sleep</code> — заставляет корутину уснуть на определённое количество секунд.</li>
<li><code>wait</code>/<code>wait_for</code> — удобные функции, чтобы дождаться выполнения уже запущенной корутины.</li>
</ul>
<p>Также стоит ознакомиться с основными функциями <code>event_loop</code>:</p>
<ul>
<li><code>get_event_loop</code> — получить новый объект <code>event_loop</code> или тот, что уже существует. При этом одновременно может существовать только один объект <code>event_loop</code>.</li>
<li><code>run_until_complete</code>/<code>run</code> — удобные функции для запуска и проверки асинхронных функций.</li>
<li><code>shutdown_asyncgens</code> — одна из самых недооценённых функций цикла событий, которая позволяет правильно завершить выполнение цикла событий и всех корутин.</li>
<li><code>call_soon</code> — позволяет запланировать выполнение корутины, но не ждать её выполнения. Таким образом можно вечно ставить на выполнение одну и ту же функцию.</li>
</ul>
<p>Теперь стоит поговорить про ключевые различия между asyncio и предложенной реализацией цикла событий. Asyncio работает на функциях обратного вызова или колбэках (callback). Этот механизм запускает задачи «честнее», чем текущий планировщик. Каждая корутина по-честному ставится в очередь и исполняется. В простом планировщике переключения не произойдёт, пока вся цепочка корутин не выполнится, что блокирует выполнение остальных задач. Однако, у колбэков есть и свой недостаток — callback hell. Это состояние, когда после вызова каждой функции нужно вызвать ещё одну функцию и ещё одну функцию... Получаются интересные фрагменты кода:</p>
<pre><code class="language-python">func1.add_callback(
    func2.add_callback(
                func3.add_callback(func4)
        )
) 
</code></pre>
<p>К счастью, этого удаётся избежать через синтаксис async/await.</p>
<pre><code class="language-python">await func4()
await func3()
await func2()
await func1() 
</code></pre>
<p>Такое поведение возможно благодаря введению класса <code>Future</code>. По сути, такие объекты спасают от колбэков и делают код более линейным. В современных версиях Python <code>Future</code>-объекты для нативных корутин не нужны.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../perf/gil.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../perf/cuda.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../perf/gil.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../perf/cuda.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
